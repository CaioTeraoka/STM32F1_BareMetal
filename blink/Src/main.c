/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2024 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f103xb.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void GPIO_init(void);
void RCC_init(void);
void delay_ms(int time);

int main(void)
{
	RCC_init();
	GPIO_init();
    /* Loop forever */
	for(;;){
		GPIOC->ODR ^= GPIO_ODR_ODR13; //vai trocar o estado do pino PC13
		delay_ms(1000);
	}
}

void RCC_init(void){
	//Configurando o oscilador para 8MHz externo
	RCC->CR |= RCC_CR_HSEON;
	while(!(RCC->CR & RCC_CR_HSERDY)); //espera estabilizar
	RCC->CFGR = (RCC->CFGR & ~(RCC_CFGR_SW)); //remove as configurações anteriores
	RCC->CFGR |= RCC_CFGR_SW_HSE; //seta a fonte de clock como HSE
	RCC->CFGR &= ~(RCC_CFGR_HPRE); //reseta as configurações do AHB prescaler
	RCC->CFGR |= RCC_CFGR_HPRE_DIV1; //seta o AHB prescaler como 1
	RCC->CFGR &= ~(RCC_CFGR_PPRE1); //reseta as configurações do APB1 prescaler
	RCC->CFGR |= RCC_CFGR_PPRE1_DIV1; //seta o APB1 prescaler como 1
	RCC->CFGR &= ~(RCC_CFGR_PPRE2); //reseta as configurações do APB2 prescaler
	RCC->CFGR |= RCC_CFGR_PPRE2_DIV1; //seta o APB2 prescaler como 1
}

void GPIO_init(void){
	//Configurando a Porta PC13
	RCC->APB2ENR |= 0x01 << 4; //Habilitar o GPIOC no RCC
	GPIOC->CRH |= 0x0 << 22; //Configura como General purpose output push-pull
	GPIOC->CRH |= 0x3 << 20; //Configura como Output mode, max speed 50 MHz.
}

void delay_ms(int time){
	//Delay em milissegundos (8MHz -> 0,125us)
	uint32_t ticks = time*8000;
	SysTick->LOAD = ticks;
	SysTick->VAL = 0;
	SysTick->CTRL = SysTick_CTRL_ENABLE_Msk;
	while(!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk));
	SysTick->CTRL = 0;
}
